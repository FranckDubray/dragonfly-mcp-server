"""
Static guidance for worker_query tool (SELECT-only, schema hints, examples, relation Process<->DB)
"""

def build_worker_query_prompt() -> str:
    return (
        "OUTIL worker_query — UTILISATION STRICTE\n"
        "- Lecture seule sur la base locale du worker (SQLite).\n"
        "- N'utilise que des requêtes SELECT. Aucune mutation (INSERT/UPDATE/DELETE/CREATE...).\n\n"
        "SCHÉMA PRINCIPAL (SQLite)\n"
        "Table job_steps:\n"
        "  - id INTEGER PRIMARY KEY\n"
        "  - name TEXT                -- nom du nœud/étape (ex: has_more_mailboxes, sleep_interval, call_llm_classify_both)\n"
        "  - status TEXT              -- 'succeeded' | 'failed' | 'running' | ...\n"
        "  - started_at TEXT          -- horodatage ISO (UTC)\n"
        "  - finished_at TEXT         -- horodatage ISO (UTC)\n"
        "  - args TEXT                -- JSON des arguments (facultatif)\n"
        "  - result TEXT              -- JSON du résultat (facultatif)\n"
        "  - error TEXT               -- message erreur si failed\n\n"
        "Tables annexes utiles:\n"
        "  - job_state_kv(skey TEXT, svalue TEXT)   -- paires clé/valeur (états courants, caches)\n"
        "  - job_meta(skey TEXT, svalue TEXT)       -- métadonnées (worker_name, persona, graph_mermaid, etc.)\n\n"
        "RELATION PROCESS ↔ BASE\n"
        "- job_steps.name correspond EXACTEMENT aux identifiants des nœuds du diagramme Mermaid (processus).\n"
        "- Le processus (Mermaid) décrit la logique d'enchaînement des étapes.\n"
        "- La base (job_steps) consigne l'historique des étapes réellement exécutées (une ligne par step).\n"
        "→ Pour analyser l'activité, interroge job_steps en t'appuyant sur les noms de nœuds Mermaid.\n\n"
        "EXEMPLES RECOMMANDÉS\n"
        "1) Dernières étapes (limite courte):\n"
        "   SELECT id, name, status, COALESCE(finished_at, started_at) AS ts\n"
        "   FROM job_steps\n"
        "   ORDER BY id DESC\n"
        "   LIMIT 20;\n\n"
        "2) Nombre d'étapes dans la dernière heure relative au max ts en DB:\n"
        "   SELECT COUNT(*) AS c\n"
        "   FROM job_steps\n"
        "   WHERE strftime('%s', COALESCE(finished_at, started_at)) >= (\n"
        "     (SELECT MAX(strftime('%s', COALESCE(finished_at, started_at))) FROM job_steps) - 3600\n"
        "   );\n\n"
        "3) Répartition par status:\n"
        "   SELECT status, COUNT(*) AS c\n"
        "   FROM job_steps\n"
        "   GROUP BY status\n"
        "   ORDER BY c DESC;\n\n"
        "4) Étapes liées au LLM:\n"
        "   SELECT id, name, status, COALESCE(finished_at, started_at) AS ts\n"
        "   FROM job_steps\n"
        "   WHERE name LIKE 'call_llm%' OR name LIKE 'call llm%'\n"
        "   ORDER BY id DESC\n"
        "   LIMIT 20;\n\n"
        "5) Lire une clé d'état récente:\n"
        "   SELECT skey, svalue\n"
        "   FROM job_state_kv\n"
        "   WHERE skey IN ('current_node','current_args','graph_mermaid')\n"
        "   ORDER BY rowid DESC\n"
        "   LIMIT 10;\n\n"
        "CONSIGNES\n"
        "- TOUJOURS ajouter LIMIT (20, 50, 100) pour éviter des réponses trop longues.\n"
        "- Préfère des sorties synthétiques pour TTS (comptages, listes courtes, résumé).\n"
        "- Utilise COALESCE(finished_at, started_at) pour trier par date.\n"
        "- Évite les jointures coûteuses; la DB est locale et petite mais viser l'efficacité.\n"
    )
