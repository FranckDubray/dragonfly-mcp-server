# 🔍 MÉTHODOLOGIE AUDIT TOOLS

## État: 13/40 audités
telegram_bot: 9.2/10 | discord_bot: 9.6/10 | ship_tracker: 9.4/10 | youtube_download: 9.3/10 | sqlite_db: 9.0/10 | gitbook: 8.9/10 | pdf_search: 8.8/10 | chess_com: 8.8/10 | date: 8.5/10 | academic_research_super: 8.1/10 | random: créé

**27 restants**: astronomy, aviation_weather, call_llm, coingecko, device_location, discord_webhook, email_send, excel_to_sqlite, ffmpeg_frames, flight_tracker, generate_edit_image, git, google_maps, http_client, imap, math, news_aggregator, office_to_pdf, ollama_local, open_meteo, pdf2text, pdf_download, reddit_intelligence, script_executor, ssh_admin, trivia_api, universal_doc_scraper, velib, video_transcribe, youtube_search

---

## PROCESS (10 étapes)

### 1. SÉLECTION
`random pick_random` sur la liste des 27 restants

### 2. CHARGEMENT
```
load_file: ["src/tools/{tool}.py", "src/tool_specs/{tool}.json", "src/tools/_{tool}/*.py"]
```

### 3. TESTS PRÉLIMINAIRES

**⚠️ CRITIQUE: Appels UN PAR UN (jamais parallèle) sinon échec système**

**⚠️ IMPORTANT: NE PAS FAIRE `/tools?reload=1` - FLOODS LE LLM (119KB JSON)**

A. **Reload silencieux d'abord**:
   ```
   http_client GET http://127.0.0.1:8000/tools?reload=1
   ```
   → Ne PAS examiner le body (trop gros), juste vérifier status 200

B. **Charger JSON spec localement**:
   ```
   load_file: "src/tool_specs/{tool}.json"
   ```
   → Examiner le JSON pour comprendre les operations/params

C. **5 tests baseline** (UN PAR UN):
   1. Opération simple (get_info/list)
   2. Avec params (search + query)
   3. Validation (param invalide)
   4. Edge case (limite dépassée)
   5. Opération complexe

D. **Observations**:
   - Outputs propres/verbeux ?
   - Erreurs claires ?
   - Validation stricte ?
   - Truncation warnings ?
   - Counts explicites (total vs returned) ?
   - Timeouts OK ?

### 4. AUDIT

**JSON Spec**:
- [ ] category, displayName, additionalProperties:false
- [ ] Arrays avec items, enums complets
- [ ] required corrects, defaults explicites
- [ ] Descriptions claires (1 ligne max)
- [ ] Cohérence JSON ↔ tests

**Code**:
- [ ] Output size: limits + truncation warnings
- [ ] Validation stricte
- [ ] Try-catch global
- [ ] Timeouts cohérents
- [ ] Logging minimal
- [ ] Pas side-effects import

**Notation** (score /10 par critère):
JSON Spec LLM | Architecture | Sécurité | Robustesse | Conformité | Performance | Maintenabilité | Documentation

**Pénalités**:
- Validation faible → Robustesse -2
- Outputs verbeux → Conformité -2
- Pas truncation warning → Performance -1
- Erreurs floues → Documentation -1

### 5. CORRECTIFS

**⚠️ DÉCOUPAGE FICHIERS**: Si un fichier dépasse 10KB ou 300 lignes, découper logiquement en modules séparés (api.py, core.py, validators.py, utils.py, services/).

Format commit:
```
fix({tool}): critical audit fixes (X.X→Y.Y/10)

🔴 CRITICAL: [bugs tests 1-5]
🟡 MAJOR: [outputs, validation]
🟢 IMPROVEMENTS: [truncation, logging]

TECHNICAL: files modifiés, conformité XX%→YY%
AUDIT SCORE: X.X→Y.Y/10
```

### 6. TESTS VALIDATION

**⚠️ UN PAR UN**

Reload tools silencieux → Re-tester uniquement ce qui posait problème:
- Bugs détectés → vérifier correction
- Outputs verbeux → vérifier simplification
- Validation faible → vérifier renforcement

### 7. TESTS NON-RÉGRESSION

**⚠️ OBLIGATOIRE - UN PAR UN**

A. **Identifier** toutes fonctionnalités:
   - Toutes opérations
   - Tous providers/sources
   - Tous filtres (dates, limites)
   - Multi-sources, edge cases

B. **Tester exhaustivement**:
   - Chaque source individuellement
   - Combinaisons multi-sources
   - Filtres temporels
   - Overrides limites
   - Nouveaux paramètres ajoutés

C. **Tableau synthèse OBLIGATOIRE**:
```
| Test | Fonctionnalité | Avant | Après | Statut |
|------|----------------|-------|-------|--------|
| ✅ 1 | Source A | ✅ | ✅ | OK |
| ✅ 2 | Source B | ✅ | ✅ | OK |
| ✅ 3 | Multi-sources | ✅ | ✅ | OK |
| ❌ 4 | Feature X | ✅ | ❌ | CASSÉ |
```

D. **Si régression**: STOP → analyser → corriger → re-tester → reprendre 7A

E. **Validation finale**: Tous tests ✅ → commit

### 8. CHANGELOG

Ajouter dans `[Unreleased]`:
```markdown
### {tool} - [DATE] ✅ AUDITED (X.X→Y.Y/10)

**Fixed**: [bugs tests]

**Technical**: files modifiés, conformité XX%→YY%

**Tests**: X/X non-régression OK.

**SCORE FINAL: Y.Y/10** ⭐⭐⭐⭐

**Known Issues**: [si applicable]
```

**Si CHANGELOG > 10KB**: rotation obligatoire → `changelogs/CHANGELOG_{start}_to_{end}.md`

### 9. COMMIT + PUSH

```bash
git commit_all -m "fix({tool}): critical audit fixes (X.X→Y.Y/10)
[message détaillé étape 5]
✅ Non-régression: X/X tests OK"

git push main
```

### 10. UNLOAD + MAJ PROCÉDURE

```bash
unload_file: ["src/tools/{tool}.py", "src/tool_specs/{tool}.json", "src/tools/_{tool}/*.py"]
```

**Mettre à jour cette procédure**:
- Incrémenter compteur (12→13/40)
- Ajouter tool à liste audités (ordre décroissant score)
- Retirer de liste restants
- Commit: `docs(audit): update methodology - {tool} audited (X/40)`

---

## RÈGLES ABSOLUES

1. 🚨 **Appels UN PAR UN** (jamais parallèle http_client)
2. 🚨 **NE PAS examiner body de `/tools?reload=1`** (119KB, floods LLM)
3. **Charger JSON spec localement** avant tests
4. **Tests avant audit** (étape 3)
5. **Outputs minimaux** (pas metadata success/operation)
6. **Truncation warnings** si > 50 items
7. **Tests validation** après correctifs
8. 🚨 **Tests non-régression OBLIGATOIRES**
9. **CHANGELOG** màj + rotation si > 10KB
10. **Perplexity** pour 404/bugs API externes
11. **Unload** toujours à la fin
12. **Procédure** màj après chaque audit
13. 🚨 **Découpage fichiers** si > 10KB ou 300 lignes
14. 🚨 **CHANGELOG condensé** (essentiel uniquement, pas de blabla)

---

## COMMANDE REPRISE

```
Audite le prochain tool (random)
```

Workspace: LLM_DEV_GUIDE.md, README.md, CHANGELOG.md, procédure
